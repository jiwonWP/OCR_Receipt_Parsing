# SPRINT1 — OCR 샘플 JSON 전수 조사 보고서
(Loader / Preprocessor 설계 근거 문서)

## 1. 조사 목적

본 문서는 OCR 결과(JSON)를 **전수 조사**한 결과를 정리한 문서이다.  
OCR 특성상 입력 텍스트는 형식적 일관성이 없고, 동일한 정보라도 다양한 방식으로 인식되기 때문에  
Extractor을 바로 설계하는 것은 오탐 가능성이 높다고 판단하였다.

따라서 다음 목표를 두고 조사를 진행하였다.

- OCR 텍스트에서 **실제로 반복되는 패턴과 노이즈 유형을 식별**
- 특정 패턴을 **어떤 이유로 그렇게 가정했는지** 논리적 근거를 명시
- AI 기반 규칙 제안에 의존하지 않고, **수동 정규화 로직이 필요한 지점**을 명확히 구분
- Loader → Preprocessor 단계에서 수행해야 할 책임과 범위를 확정

---

## 2. 조사 대상 데이터

- OCR 결과 JSON 파일 4종
- 공통 특징
  - 계량 증명서 / 계량 확인서 / 계량표 계열 문서
  - 차량 계량 정보를 포함
- **`text` 필드에 포함된 OCR 결과 문자열만을 분석 대상으로 사용**

---

## 3. 샘플별 전수 조사 결과

---

### 3.1 Sample 1 — 계량 증명서

#### 원문에서 확인된 주요 라인

- `계량일자: 2026-02-02 0016`
- `05:26:18 12,480 kg`
- `05:36:01 7,470 kg`
- `실 중 량: 5,010 kg`
- `2026-02-02 05:37:55`
- `37.105317, 127.375673`

#### 관찰된 특징

1. **날짜 뒤에 의미가 불명확한 숫자(`0016`)가 결합**
   - `2026-02-02 0016`
   - 콜론(`:`)이 없어 정상적인 시간 형식이라고 보기 어려움
   - 문서 말미에는 `2026-02-02 05:37:55`와 같은 정상 타임스탬프가 별도로 존재

2. **총중량 / 차중량 라벨이 명확하지 않음**
   - `05:26:18 12,480 kg`
   - `05:36:01 7,470 kg`
   - 시간 + 중량만 존재하고, 총/차 라벨이 누락됨

3. **실중량은 명확한 라벨로 별도 표기**
   - `실 중 량: 5,010 kg`

4. **좌표 정보 존재**
   - `위도,경도` 형태의 실수 좌표 쌍

#### 기술적 가정 및 근거

- 가정 1  
  `12,480 kg`와 `7,470 kg`는 각각 총중량/차중량 후보이다.

  **근거**
  - 두 값의 차이: `12,480 - 7,470 = 5,010`
  - 이는 문서에 명시된 `실중량 5,010 kg`과 정확히 일치

- 가정 2  
  `0016`은 시간으로 단정하지 않고 **raw_tail** 로 취급한다.

  **근거**
  - 정상 시간 표기(`HH:MM:SS`)가 같은 문서에 존재
  - OCR 특성상 시각 일부만 잘려 인식되었을 가능성
  - 섣불리 `00:16`으로 변환하면 오탐 위험

#### 결론

- 날짜 뒤 숫자는 **삭제하지 않고 분리/보존**해야 함
- 라벨 없는 중량은 **후속 검증(총-차=실)** 을 통해 판단 가능
- 전처리 단계에서 좌표 포맷을 통일하면 추출이 쉬워짐

---

### 3.2 Sample 2 — 계근표

#### 원문에서 확인된 주요 라인

- `날 짜: 2026-02-02-00004`
- `차번호: 80구8713`
- `구 분: 입고`
- `총중량: 02 : 07 13 460 kg`
- `차중량: 02 : 13 7 560 kg`
- `실중량: 5 900 kg`
- `2026-02-02 02:14:23`
- `37.718114, 126.844940`

#### 관찰된 특징

1. **날짜 뒤에 추가 숫자 블록 결합**
   - `2026-02-02-00004`
   - 날짜 형식 표준(`YYYY-MM-DD`)과 불일치

2. **중량 숫자가 공백으로 분절**
   - `13 460 kg`
   - `7 560 kg`
   - `5 900 kg`

3. **시간 표기에서 구두점 주변 공백**
   - `02 : 07`
   - `02 : 13`

#### 기술적 가정 및 근거

- 가정 1  
  `-00004`는 날짜가 아니라 **문서 식별자 또는 시퀀스**이다.

  **근거**
  - 날짜 표준과 맞지 않음
  - 날짜 외에 식별자를 붙이는 문서 포맷은 흔함
  - 삭제 시 정보 손실 발생 가능

- 가정 2  
  `13 460 kg`는 `13,460 kg`으로 결합해야 한다.

  **근거**
  - 총/차/실 모든 중량이 동일한 패턴으로 분절됨
  - 수치 검산: `13,460 - 7,560 = 5,900` → 실중량과 정확히 일치
  - OCR이 콤마를 공백으로 인식한 전형적 사례

#### 결론

- 숫자 결합은 **무조건이 아니라 `kg` 근처에서만 수행**해야 함
- 날짜 뒤 suffix는 **분리 + 보존** 필요
- 구두점 주변 공백 정리는 전처리 필수

---

### 3.3 Sample 3 — 계량 확인서

#### 원문에서 확인된 주요 라인

- `계량 일자: 2026-02-01 5`
- `차량 번호: 5405 입고`
- `총 중 량 : 11시 33분 14,080 kg`
- `공차중량 : 11시 39분 13,950 kg`
- `실 중 량 : 130 kg`
- 주소 / 전화번호 다수 포함
- `2026-02-01 11:55:35`

#### 관찰된 특징

1. **한글 시간 표현**
   - `11시 33분`
   - `11시 39분`

2. **차량번호 값에 구분 정보가 결합**
   - `5405 입고`

3. **날짜 뒤 단일 숫자(`5`)**
   - 의미 불명확

4. **비핵심 텍스트(주소/전화) 다량 포함**

#### 기술적 가정 및 근거

-  `11시 33분`은 `11:33`으로 정규화 가능하다.

  **근거**
  - 의미가 명확한 시간 표현
  - 동일 문서에 `11:55:35` 같은 정상 시각 존재

- 차량번호는 숫자만 추출하고, `입고`는 구분 정보로 분리한다.

  **근거**
  - 다른 샘플에서도 `입고/출고`는 독립 필드
  - 값 필드에 결합되면 차량번호 추출 실패 가능

-   날짜 뒤 `5`는 시간으로 확정하지 않는다.

  **근거**
  - 정상 타임스탬프가 이미 존재
  - 불완전 OCR 가능성 높음

#### 결론

- 한글 시간은 전처리 단계에서 통일 필요
- 값 오염은 **삭제가 아니라 분리**가 안전
- 주소/전화는 삭제하지 않고 유지하되, 핵심 라벨 기반 추출로 대응

---

### 3.4 Sample 4 — 계량 증명표

#### 원문에서 확인된 주요 라인

- `차량 No. 0580`
- `일 시 2025-12-01`
- `계량횟수 0022`
- `총 중 량 14,230 kg (09:09)`
- `공차중량 12,910 kg (09:09)`
- `실 중 량 1,320 kg`
- `감 량 0 kg`
- `비 고 1,320 kg`

#### 관찰된 특징

- 라벨 표기가 가장 명확
- 중량 뒤 괄호 시간 존재
- 실중량이 비고에 중복 표기됨

#### 결론

- 이 샘플을 **표준 레퍼런스 포맷**으로 삼을 수 있음
- 다른 샘플의 깨진 패턴을 이 구조에 맞게 정규화하는 전략

---

## 4. 공통 노이즈 유형 요약

| 유형 | 실제 예시 | 대응 전략 |
|---|---|---|
| 라벨 분절 | `실 중 량`, `날 짜` | 라벨 표준화 |
| 시간 다양성 | `02 : 13`, `11시 33분` | 시간 포맷 통일 |
| 숫자 분절 | `5 900 kg` | 단위 근처 결합 |
| 날짜 suffix | `2026-02-02-00004` | 분리 + 보존 |
| 불명확 꼬리 | `2026-02-02 0016` | raw_tail 보존 |
| 값 오염 | `5405 입고` | 값/구분 분리 |
| 잡음 텍스트 | 주소/전화 | 삭제 X, 라벨 기반 추출 |

---

## 5. 핵심 결론

1. OCR 텍스트는 **형식이 아니라 패턴과 정합성으로 이해하기.**
2. AI가 제안한 일반적인 정규식만으로는 OCR 노이즈를 안전하게 처리하기 어렵다.
3. 전처리는 “과감한 치환”보다 **보수적 분리/보존 전략** 사용하기

본 전수 조사 결과를 바탕으로,  
이후, Sprint2에서는 본 문서에서 정의한 가정과 규칙을 코드로 구현한다.