# OCR 데이터 처리 파이프라인 아키텍처 설계
(Loader → Preprocessor → Extractor → Validator → Exporter)

## 1. 설계 목적

본 프로젝트는 OCR 결과(JSON)의 `text` 필드를 입력으로 받아  
날짜, 차량번호, 중량(총/차/실) 등 핵심 정보를 구조화된 데이터로 추출하는 것을 목표로 한다.

OCR 입력은 다음과 같은 특성을 가진다.

- 형식적 일관성이 없음
- 동일한 정보가 여러 표현 방식으로 등장
- 일부 정보는 불완전하거나 중복됨
- 노이즈와 의미 있는 정보가 혼재됨

따라서  
**단일 단계에서 모든 처리를 수행하는 방식이 아닌**,  
책임이 명확히 분리된 파이프라인 구조를 채택하였다.

---

## 2. 전체 파이프라인 개요
Loader
→ Preprocessor
→ Extractor
→ Validator
→ Exporter

각 단계는 **명확한 책임 범위**를 가지며,  
앞 단계의 출력이 다음 단계의 입력이 된다.

---

## 3. 단계별 역할과 책임

---

### 3.1 Loader

#### 역할
- OCR 결과 JSON 파일을 읽는다.
- JSON 내부의 `text` 필드를 로드한다.
- 원문 텍스트를 **변형하지 않고 그대로 보존**한다.

#### 책임 범위
- 파일 I/O
- JSON 파싱
- 원문 보존

- 제외되는 것 (공백 정리, 문자 치환, 의미 해석, 패턴 추출)

#### 설계 판단 근거
- OCR 원문은 추후 규칙 개선, 오류 재현의 근거 데이터이므로  
  Loader 단계에서 변형될 경우 디버깅과 검증이 어려워진다.
- 따라서 Loader는 “읽기 전용 단계”로 유지한다.

#### 출력 데이터 구조
- `RawDocument`
  - `source_path`
  - `raw_text`
  - `meta` 

---

### 3.2 Preprocessor

#### 역할
- OCR 텍스트의 **형태를 통일**하고,
- 추출을 방해하는 노이즈를 **분리하거나 보존**한다.

#### 핵심 원칙
- **의미를 확정하지 않는다**
- **삭제보다 분리/보존을 우선한다**
- **과치환은 피한다**

#### 수행 작업
- 라벨 표준화 (`날 짜` → `날짜`)
- 구두점 주변 공백 제거 (`02 : 13` → `02:13`)
- 한글 시간 정규화 (`11시 33분` → `11:33`)
- 중량 숫자 분절 결합 (`5 900 kg` → `5,900 kg`)
- 날짜 뒤 suffix 분리 (`2026-02-02-00004`)
- 불명확한 꼬리 숫자 보존 (`raw_tail`)
- 값 필드 오염 분리 (`5405 입고`)

#### 제외되는 것
- 이 중량이 총중량인지/차중량인지 판단
- 날짜/시간을 확정된 timestamp로 변환
- 데이터 유효성 판단

#### 설계 판단 근거
- OCR 노이즈는 케이스가 다양해, 전처리 단계에서 의미까지 확정하면 오탐 위험이 커진다.
- Preprocessor는 **Extractor가 일관된 입력을 받을 수 있도록 돕는 역할**에 집중한다.

#### 출력 데이터 구조
- `PreprocessedDocument`
  - `raw_text`
  - `normalized_text`
  - `applied_rules` (적용된 정규화 규칙 목록)
  - `warnings` (애매한 패턴 발견 기록)

---

### 3.3 Extractor

#### 역할
- 정규화된 텍스트에서 **구조화된 필드**를 추출한다.

#### 추출 대상
- 날짜
- 시간
- 차량번호
- 총중량
- 차중량(공차중량)
- 실중량
- 구분(입고/출고)
- 계량횟수
- 좌표(선택)

#### 설계 원칙
- 라벨 기반 추출을 우선한다.
- 라벨이 없는 경우, **패턴 + 정합성 검증**을 통해 보완한다.

#### 제외되는 것
- 데이터의 “정상/비정상” 판정
- 범위 기반 유효성 판단

#### 설계 판단 근거
- 추출과 검증을 분리하면,
  - 추출 로직은 단순해지고 검증 기준을 독립적으로 확장 가능하다.

---

### 3.4 Validator

#### 역할
- Extractor가 추출한 데이터가 **논리적으로 타당한지** 검증한다.
- 누락된 값이 있을 경우, 가능한 범위 내에서 **복구** 를 수행한다.

#### 검증 예시
- 날짜 형식 유효성
- 중량 값이 음수가 아닌지
- 총중량 ≥ 차중량
- `(총중량 - 차중량 == 실중량)` 관계 성립 여부
- 필수 필드 누락 여부

#### 출력
- 검증 통과 여부
- 실패 사유(에러 코드 / 메시지)

#### 설계 판단 근거
- 모든 데이터를 억지로 “맞다”고 만들기보다,
  **의심되는 데이터는 명시적으로 실패 처리**하는 것이 신뢰도를 높인다.

#### 복구 정책
- `net_weight(실중량)`이 누락되었고, `gross_weight(총중량)`과 `tare_weight(차중량)`이 존재할 경우:
  - `net_weight = gross_weight - tare_weight` 로 생성한다.
  - 생성된 값은 다음 메타데이터를 반드시 남긴다:
    - `strategy_used = computed_imputation`
    - `is_imputed = true`
    - `raw_match = None` 
    - `notes = "imputed: net_weight = gross_weight - tare_weight"`

> 본 프로젝트의 Robustness 목표는 "실패를 줄이되, 근거 없이 확정하지 않는 것"
> 따라서 복구는 명시적 플래그(is_imputed)와 전략(strategy_used)을 동반한다.

---

### 3.5 Exporter

#### 역할
- 검증이 끝난 데이터를 외부에서 활용 가능한 형태로 저장한다.

#### 출력 예시
- CSV
- JSON
- DB Insert용 구조

#### 설계 판단 근거
- 출력 형식은 프로젝트 후반 요구사항에 따라 변경 가능하므로,
  Exporter를 독립 모듈로 분리해 변경 비용을 최소화한다.

---

## 4. 단계 분리의 핵심 설계 철학

### 4.1 “의미 확정은 최대한 뒤로 미룬다”

- OCR 입력은 불완전
- 애매한 값을 초기에 확정하면 오탐을 되돌리기 어렵다.
- 따라서:
  - Preprocessor: 분리/보존
  - Extractor: 후보 추출
  - Validator: 확정/거부

---

### 4.2 “삭제보다 기록”

- raw_tail, doc_seq, warnings 등을 남긴다.
- 실패 케이스도 다음 규칙 개선의 근거 데이터로 활용 가능하다.

---
